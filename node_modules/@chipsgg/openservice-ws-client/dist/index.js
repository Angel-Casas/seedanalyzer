function e(e){return e&&'object'==typeof e&&'default'in e?e:{default:e}}Object.defineProperty(exports,'__esModule',{value:!0});var n=e(require('assert')),t={decode:function(e){return JSON.parse(e)},encode:function(e){return JSON.stringify(e)},isEvent:function(e){return null==e[1]},isRpc:function(e){return null!=e[1]}};const r=t.touch=function(e={},n=[],t=(e=>e),o=0){if(0==n.length)return data;if(o==n.length-1)return t(e,n[o]),e;const s=n[o];return e[s]={...e[s]},r(e[s],n,t,o+1),e};t.set=function(e,n,t){return r(e,n,((e,n)=>e[n]=t))};const o=t.unset=function(e={},n=[],t=((e,n)=>delete e[n]),r=0){if(0==n.length)return data;if(r==n.length-1)return t(e,n[r]),e;const s=n[r];return null==e[s]||(e[s]={...e[s]},o(e[s],n,t,r+1)),e},{set:s,unset:c}=t;const{encode:u}=t;const a=n.default;const i=(e={})=>(n,[t=[],r])=>(t.length?e[n]=null==r?c({...e[n]},t):s({...e[n]},t,r):e[n]=r,e[n]),l=n.default,f=(e,n,t=(e=>e))=>async()=>{const r=new e(n);return await new Promise(((e,n)=>{r.onopen=n=>{r.readyState===r.OPEN&&(t('open',n),e())},r.onerror=e=>n(e),r.onclose=e=>n(e)})),r.onmessage=e=>t('message',e.data),r.onerror=e=>t('error',e),r.onclose=e=>t('close',e),r.onopen=e=>{r.readyState===r.OPEN&&t('open',e)},r},d=e=>{const n=new Map;let t=0;return{call:function(e,r){return(o,...s)=>new Promise(((c,a)=>{n.set(++t,[c,a]);try{e().send(u([r,t,o,s]))}catch(e){a(e)}}))},response:function(e){const[t,r,o,s]=e;if(!n.has(r))return;const[c,u]=n.get(r);if(s){const[e,n]=s,t=new Error(e);t.stack=n,u(t)}else c(o);n.delete(r)},pending:n}},p=({keepalive:e=3e4},{ws:n,connect:t},r=(e=>e))=>{let o;async function s(){n.readyState,n.OPEN,n.readyState===n.CLOSED&&await t().then((e=>{r('reconnect',n=e)})).catch((e=>{})),o=setTimeout(s,e)}return a(e,'requires keepalive value in ms'),{pause:()=>clearTimeout(o),resume(){if(!o)return s()}}},{decode:h,isEvent:g,isRpc:m}=t;var y=async(e,n={},t=(e=>e),r={})=>{const{host:o,channels:s=[]}=n;l(o,'requires host'),l(s,'requires channels');const c=d(),u=i(r);const a=f(e,o,((e,n)=>{'message'==e?function(e,n){const o=h(n);let s=!1;o.forEach((e=>{g(e)?(s=!0,u(e[0],e[2])):m(e)&&c.response(e)})),s&&t('change',r)}(0,n):t(e,n)}));let y=await a();function w(){return y}const v=p(n,{ws:y,connect:a},((e,n)=>{y=n,t(e,y)}));v.resume();return s.reduce(((e,n)=>(e.actions[n]=c.call(w,n),e)),{actions:{},rpc:c,getWs:w,setState:u,...v,connect:a,close:function(){v.pause(),y.close()}})};var w=y;exports.default=w,module.exports=exports.default;
